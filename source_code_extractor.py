#!/usr/bin/env python3
"""
source_code_extractor.py

Flatten a source code repository into a single text file:
  - relative path + file content
  - skips common build / cache / binary / media files
  - configurable via CLI flags
"""

import argparse
import os
import sys
from dataclasses import dataclass, field
from typing import Set, List


# ---------- Defaults ----------

DEFAULT_IGNORE_DIRS = {
    "node_modules",
    "venv",
    ".venv",
    "__pycache__",
    ".git",
    ".hg",
    ".svn",
    ".idea",
    ".vscode",
    "build",
    "dist",
    "target",
    "out",
    "bin",
    "obj",
    ".gradle",
    ".terraform",
    ".pytest_cache",
    ".mypy_cache",
}

DEFAULT_IGNORED_EXT = {
    # binary / compiled
    ".exe", ".dll", ".so", ".dylib", ".pdb",
    ".class", ".o", ".obj", ".a", ".lib",
    ".pyc", ".pyo",

    # archives
    ".zip", ".tar", ".tar.gz", ".tgz", ".rar", ".7z",

    # images
    ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".ico", ".webp",

    # video
    ".mp4", ".mkv", ".mov", ".avi", ".wmv", ".flv", ".webm",

    # audio
    ".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a",

    # fonts
    ".ttf", ".otf", ".woff", ".woff2",

    # databases / data blobs / logs
    ".db", ".sqlite", ".sqlite3", ".mdb",
    ".bak",

    # office / pdf
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
}

DEFAULT_IGNORED_FILENAMES = {
    "package-lock.json",
    "yarn.lock",
    "pnpm-lock.yaml",
    ".DS_Store",
}

DEFAULT_MAX_FILE_SIZE = 1 * 1024 * 1024  # 1MB


# ---------- Helpers ----------

def parse_size(size_str: str) -> int:
    """
    Parse human-friendly size like "500KB", "2MB", "1G" into integer bytes.
    """
    s = size_str.strip().upper()
    if not s:
        raise ValueError("Empty size string")

    units = {
        "B": 1,
        "KB": 1024,
        "MB": 1024 ** 2,
        "GB": 1024 ** 3,
    }

    for suffix in ("GB", "G", "MB", "M", "KB", "K", "B"):
        if s.endswith(suffix):
            num_part = s[:-len(suffix)].strip()
            if not num_part:
                raise ValueError(f"Invalid size: {size_str}")
            value = float(num_part)
            if suffix in ("G", "GB"):
                return int(value * units["GB"])
            if suffix in ("M", "MB"):
                return int(value * units["MB"])
            if suffix in ("K", "KB"):
                return int(value * units["KB"])
            if suffix == "B":
                return int(value * units["B"])
    # no suffix â†’ assume bytes
    return int(float(s))


def is_probably_binary(path: str, max_bytes: int = 8000) -> bool:
    """
    Heuristic to decide if a file is likely binary.
    Reads up to `max_bytes` and checks for NUL bytes and
    high ratio of non-printable characters.
    """
    try:
        with open(path, "rb") as f:
            chunk = f.read(max_bytes)
    except OSError:
        return True

    if not chunk:
        return False

    # NUL byte = almost certainly binary
    if b"\x00" in chunk:
        return True

    # Count bytes that are not typical text:
    # printable ASCII + common whitespace
    printable = set(range(32, 127))
    whitespace = {9, 10, 13}  # \t, \n, \r

    non_text_bytes = 0
    for b in chunk:
        if b not in printable and b not in whitespace:
            non_text_bytes += 1

    ratio = non_text_bytes / len(chunk)
    return ratio > 0.30


@dataclass
class ExtractConfig:
    project_dir: str
    output_file: str
    max_file_size: int = DEFAULT_MAX_FILE_SIZE
    ignore_dirs: Set[str] = field(default_factory=lambda: set(DEFAULT_IGNORE_DIRS))
    ignore_ext: Set[str] = field(default_factory=lambda: set(DEFAULT_IGNORED_EXT))
    ignore_filenames: Set[str] = field(default_factory=lambda: set(DEFAULT_IGNORED_FILENAMES))
    include_ext: Set[str] = field(default_factory=set)  # if non-empty, acts as whitelist
    follow_symlinks: bool = False


def should_ignore_dir(dir_name: str, cfg: ExtractConfig) -> bool:
    return dir_name in cfg.ignore_dirs


def should_ignore_file(filename: str, cfg: ExtractConfig) -> bool:
    if filename in cfg.ignore_filenames:
        return True

    _, ext = os.path.splitext(filename)
    ext = ext.lower()

    # If user specified include_ext, enforce whitelist
    if cfg.include_ext and ext not in cfg.include_ext:
        return True

    if ext in cfg.ignore_ext:
        return True

    return False


def extract_project(cfg: ExtractConfig) -> None:
    total_files = 0
    written_files = 0
    skipped_binary = 0
    skipped_large = 0
    skipped_ignored = 0
    skipped_errors = 0

    with open(cfg.output_file, "w", encoding="utf-8") as out:
        out.write(f"# Source code dump generated by source-code-extractor\n")
        out.write(f"# Project: {cfg.project_dir}\n\n")

        for root, dirs, files in os.walk(cfg.project_dir, followlinks=cfg.follow_symlinks):
            # filter dirs in-place
            dirs[:] = [d for d in dirs if not should_ignore_dir(d, cfg)]

            for name in files:
                total_files += 1

                if should_ignore_file(name, cfg):
                    skipped_ignored += 1
                    continue

                full_path = os.path.join(root, name)
                rel_path = os.path.relpath(full_path, cfg.project_dir)

                try:
                    size = os.path.getsize(full_path)
                except OSError as e:
                    skipped_errors += 1
                    out.write(f"\n=== FILE: {rel_path} (ERROR: os.path.getsize failed: {e}) ===\n")
                    continue

                if size > cfg.max_file_size:
                    skipped_large += 1
                    out.write(
                        f"\n=== FILE: {rel_path} (SKIPPED: too large, {size} bytes) ===\n"
                    )
                    continue

                if is_probably_binary(full_path):
                    skipped_binary += 1
                    out.write(
                        f"\n=== FILE: {rel_path} (SKIPPED: binary-like content) ===\n"
                    )
                    continue

                try:
                    with open(full_path, "r", encoding="utf-8", errors="ignore") as f:
                        content = f.read()
                except OSError as e:
                    skipped_errors += 1
                    out.write(f"\n=== FILE: {rel_path} (ERROR: {e}) ===\n")
                    continue

                out.write(f"\n\n=== FILE: {rel_path} (size: {size} bytes) ===\n")
                out.write(content)
                out.write("\n")
                written_files += 1

    print(f"[source-code-extractor] Done.")
    print(f"  Project directory : {cfg.project_dir}")
    print(f"  Output file       : {cfg.output_file}")
    print(f"  Total files seen  : {total_files}")
    print(f"  Files written     : {written_files}")
    print(f"  Skipped (ignored) : {skipped_ignored}")
    print(f"  Skipped (binary)  : {skipped_binary}")
    print(f"  Skipped (too big) : {skipped_large}")
    print(f"  Skipped (errors)  : {skipped_errors}")


# ---------- CLI ----------

def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Flatten a source code repository into a single text file for code review / AI context.",
    )
    parser.add_argument(
        "-p", "--project-dir",
        default=".",
        help="Path to the project root (default: current directory).",
    )
    parser.add_argument(
        "-o", "--output",
        default="project_dump.txt",
        help="Path to output text file (default: project_dump.txt).",
    )
    parser.add_argument(
        "-s", "--max-file-size",
        default="1MB",
        help="Max size per file to include (e.g. 500KB, 1MB, 5MB). Default: 1MB.",
    )
    parser.add_argument(
        "--ignore-dir",
        action="append",
        default=[],
        help="Additional directory name to ignore (can be used multiple times).",
    )
    parser.add_argument(
        "--ignore-ext",
        action="append",
        default=[],
        help="Additional file extension to ignore (e.g. .log). Can be used multiple times.",
    )
    parser.add_argument(
        "--include-ext",
        action="append",
        default=[],
        help="Whitelist of extensions to include (e.g. .py .java .cpp). "
             "If provided, only these extensions will be included.",
    )
    parser.add_argument(
        "--follow-symlinks",
        action="store_true",
        help="Follow symbolic links when walking the directory tree.",
    )
    return parser


def main(argv: List[str] | None = None) -> None:
    parser = build_arg_parser()
    args = parser.parse_args(argv)

    try:
        max_size = parse_size(args.max_file_size)
    except ValueError as e:
        parser.error(f"Invalid --max-file-size value: {e}")

    project_dir = os.path.abspath(args.project_dir)

    cfg = ExtractConfig(
        project_dir=project_dir,
        output_file=args.output,
        max_file_size=max_size,
    )

    # merge extra ignore dirs
    for d in args.ignore_dir:
        if d:
            cfg.ignore_dirs.add(d)

    # merge extra ignored extensions
    for ext in args.ignore_ext:
        if not ext:
            continue
        if not ext.startswith("."):
            ext = "." + ext
        cfg.ignore_ext.add(ext.lower())

    # include extensions whitelist
    for ext in args.include_ext:
        if not ext:
            continue
        if not ext.startswith("."):
            ext = "." + ext
        cfg.include_ext.add(ext.lower())

    extract_project(cfg)


if __name__ == "__main__":
    main()
